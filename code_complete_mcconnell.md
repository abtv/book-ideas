Совершенный код

- I. Основы разработки
  - Глава 1: Этапы разработки и где находится конструирование
    - Определение проблемы.
    - Подготовка требований.
    - Выработка архитектуры.
    - Конструирование: детальное проектирование, кодирование, отладка, интеграция, тестирование.
    - Тестирование на соответствие требованиям.
    - Эксплуатация.
  - Глава 2: Метафоры разработки ПО
    - Цель метафоры - взглянуть на разработку по-другому, получить новую информацию.
    - Сравнивая с понятным можно разобраться в непонятном, по аналогии.
    - Проверяй: можно ошибиться как с поиском эфира учеными.
    - Метафора написания письма: устарела.
      - Подразумевает, что пишет один человек, а не команда.
      - Предполагает, что проект легко выкинуть и переписать.
      - Подразумевает, что проект не развивается.
    - Сельскохозяйственная метафора: хороша, но часть вещей сложно будет применить.
    - Метафора жемчужины (эволюционная): тоже хороша, но сложно применить.
    - Строительная метафора: на данный момент лучшая, т.к. как и разарботка софта это проектная деятельность.
  - Глава 3: Цена ошибок на разных этапах разработки
    - Метафора: семь раз отмерь - один отрежь.
    - Дороже всего обходятся ошибки в определении проблемы, требований и архитектуры. На уровне кода их исправить невозможно: нужно идти на уровень выше.
    - Подход к разработке бизнес-приложений отличается от подхода к разработке встраиваемых систем. Нужно заранее определиться какого рода систему мы пишем и определить подразумеваемые требования (производительность системы, надежность, скорость разработки).
    - Определи основные требования сразу, а остальные позже в процессе итеративной разработки. Сначала определить самые базовые требования, а детали прояснить потом.
    - Описывать проблему на языке пользователя, а не инженера. Не предлагать решение под видом описания проблемы: система отказывает в 30% случаев в час пик (хорошо) против нужно увеличить производительность системы (плохо).
    - Изменение требований: это отличная идея и мне нужно пересмотреть план работы, чтобы решить какие из требований мы уберём, чтобы успеть к этой дате. Это отрезвляющий холодный душ, который позволяет напомнить об ограниченных ресурсах и выставить приоритеты. Лучшее враг хорошего в этом случае.
    - Архитектура обеспечивает концептуальную целостность системы, над которой работает несколько человек или команд. В итоге архитектура определяет внутреннее качество системы и, в долгосрочной перспективе, внешнее качество системы.
    - Компоненты архитектуры
      - Рассмотри альтернативные варианты архитектуры и обосновануй выбранный вариант. Опиши этого в проекте.
      - Перечисли и опиши основные компоненты системы.
      - Укажи ответственность каждого компонента. Чем уже ответственность компонента тем лучше. Компонент - это класс или набор классов или функций.
      - Укажи правила взаимодействия между компонентами: какие компоненты можно использовать прямо, какие косвенно. Укажи, что нельзя делать.
      - Укажи как организованы данные: например, база данных и внешние сервисы, которые тоже хранят данные. Укажи ограничения на количество вызовов во внешние сервисы.
      - Бизнес-правила. Укажи их, в том числе подразумеваемые. Например, скорость обновления данных в кэше.
      - Пользовательский интерфейс. Должен быть модульным, чтобы было легко вносить изменения.
      - Как обрабатываются ошибки и производится логирование (Sentry, файлы, emergency Slack channel).
      - Безопасность (шифрование, протоколы, авторизация и защита ресурсов).
      - Масштабируемость.
      - Производительность.
      - Как эта архитектура позволит вносить изменения?
      - Опасаться ситуации как в анекдоте про готовку мяса и горшок: мы всегда так делали. Нужно прояснять причины вещей.
  - Глава 4: Какие решения нужно принять перед конструированием
    - Выбери подходящие инструменты и подходы: деление целых чисел было сложным до появления арабской нотации.
    - Выбор языка влияет на выразительность программы и в конечном итоге какие идеи мы можем выразить на нем.
    - Следование конвенциям программирования обеспечит целостность системы на низком уровне.
      - Читаемость: точные имена из предметной области, разбиение на абстракции и автоформатирование кода. Критерий: проснуться в 3 часа ночи и понять незнакомый код.
      - Архитектура: понимание где именно писать код для решения задачи, разбиение по областям ответственности. Задачи должны решаться единообразно. Здесь же словарь системы.
      - Тестирование: AAA-паттерн, описание тестов в терминах предметной области.
      - Логирование: писать дату и время, название системы, действие и субъект действия. Логирование поможет разобраться с ошибками в продакшене, поэтому логируй то, что будешь потом искать в логах.
    - Реализация должна соответствовать высокоуровневой архитектуре.
    - Программирование с использованием языка против программирования на языке. Даже если в языке нет каких-то средств, их можно попробовать эмулировать на уровне соглашений делать так-то. Это избавит от проблем, присущих языку.
    - Программирование с использованием VSCode против программирования в VSCode. Например, можно добавить VimMode-плагин и настроить хоткеи, к которым привык, а не использовать готовые.
  - Бонус: 3R разработки (https://github.com/ryanmcdermott/3rs-of-software-architecture)
    - Readability
      - Имена из предметной области, не общие.
      - Автоматическое форматирование и проверка кода.
      - Формирование абстракций.
    - Reusability
      - По возможности не использовать глобальное состояние/сайд-эффекты.
      - Модуль и функция должны формировать одну согласованную абстракцию.
      - Использовать ограничения на способы передачи данных.
    - Refactorability
      - В идеале статическая типизация на больших проектах с несколькими разработчиками.
      - Тесты, для проверки работоспособности системы после рефакторинга.
      - Ограничить (на уровне архитектуры) использование глобального состояния и сайд-эффектов.
- II. Качественный код
  - Глава 5. Проектирование
    - Иногда проектирование – это грязная проблема, т.е. проблема, которую можно сформулировать только попытавшись решить. Построили мост, он развалился, узнали о новой проблеме, построили новый с учетом новых знаний. Это крайний случай: лучше делать дешевые прототипы и в процессе работы узнавать о неизвестных деталях.
    - Требования могут измениться после проектирования. Эволюционная архитектура (не нужно все решать наперед, наоборот, нужно делать так, чтобы в нужных местах легко поменять).
    - Решить, что важнее среди конкурирующих требований. Чем больше ограничений, тем проще проектировать - меньше вариантов реализации.
    - В большом проекте нужно договориться о терминологии: перечислить сущности и что они значат.
    - Существенные свойства неотъемлемы от данного типа объекта, а несущественные - случайно присущи конкретному экземпляру объекта.
    - Принципы проектирования (эвристические).
      - Определить типы объектов реального мира.
      - Определить данные объекта.
      - Определить операции над объектом.
      - Определить операции, которые может выполнять этот объект над другими объектами.
      - Определить какие чести объекта открытые, а какие закрытые.
    - Уровни проектирования.
      - Уровень всей системы и надсистемы.
      - Подсистемы и способы их взаимодействия.
      - Классы, объекты и модули.
      - Методы и функции.
      - В скольких подсистемах должен разбираться разработчик, чтобы внести изменение: если нет ограничений на взаимодействие систем, то все могут использовать всех и придётся разбираться во всем. Вот тут и появляется архитектор/техлид/тимлид (в зависимости от команды), который и декомпозирует решение на задачи, которые могут качественно сделать специалисты.
    - Умственное жонглирование - думать в один момент времени только о кусочках программы.
    - Характеристики читаемых программ.
      - Простое решение, без заумности.
      - Fan in > 7 (кто использует модуль), fan out < 7 (кого использует модуль).
      - High cohesion и low coupling.
      - Чем меньше связей с другими частями приложения, тем лучше. Похоже на fan out.
    - Тренировать абстрагирование - концентрацию внимания только на определенных свойствах объекта и (в данный момент) игнорировать остальные.
    - Дом, дверь и дверная ручка это абстракции: ручка может металлическая или деревянная, но на уровне дома это не важно.
    - Инкапсуляция разрешает смотреть на объект только с определенной точки зрения.
    - Почаще задавай вопрос: что мне скрыть?
    - ++globalId (плохо) vs function getNewId() (хорошо)
    - Обращай внимание на неудачи и их причины в той же мере как на успех и его причины.
    - Принцип Одного Верного Места - держи логику в одном месте, так проще вносить изменения.
    - Рисуй схемы, чтобы на более высоком уровне взглянуть на проблему.
    - Проектируй итеративно: на верхнем уровне, потом на нижнем, потом опять на верхнем и т.д.
    - Одной итерации для проектирования может быть недостаточно: сравнивай разные варианты.
    - Восходящее и нисходящее проектирование: нужны оба. Восходящее позволяет начать, зацепиться за что-то не абстрактное, а нисходящее позволяет уместить в голове сложный проект.
    - Прототипное проектирование используется в грязных проблемах.
    - Можно проектировать совместно с другими людьми: найти слабые места или получить дополнительную экспертизу.
  - Глава 6. Классы
    - Сначала программисты думали в терминах операторов, затем методов, потом классов, затем компонентов и сервисов.
    - Абстрактный тип данных позволяет работать с моделью предметной области, а не с массивами, списками и другими низкоуровневыми структурами данных.
    - Обычный лифт в девятиэтажке как АТД может быть проще по количеству методов (операций), чем меню в программе.
    - В хорошо спроектированном классе методы интерфейса согласованы, т.е. формируют одну абстракцию, это не набор методов в разнобой (как бывает в common/util-иодулях).
    - Используй наследование только если подкласс является подтипом в реальном мире. EmployeeList не должен наследоваться от List, т.к. будут выставлены наружу низкоуровневые методы и EmployeeList не является подтипом List в реальном мире.
    - Классы с high cohesion обычно формируют согласованную абстракцию.
    - Инкапсуляция не позволяет получить доступ к данным даже если мы этого захотим.
  - Глава 7. Методы
    - Методы абстрагируют действия. Один метод - одно действие.
    - Объём метода менее важен, чем сформировать абстракцию.
    - Использовать методы для сложных логических проверок.
    - Виды связности:
      - Функциональная связность (one action).
      - Последовательная связность (pipeline of actions).
      - Временная связность (setup, tear down).
      - Логическая связность (switch).
      - Случайная связность (chaos).
    - Передавай аргументы в методы в определенном порядке.
    - Если ты передаёшь из одних методов в другие слишком много аргументов, то сгруппируй эти методы в один класс.
    - Какую абстракцию формирует интерфейс метода? Если она есть, то можно передавать одним аргументом, а если нет, то несколькими.
  - Глава 8. Защитное программирование
    - История: часть плавучего моста затонула во время шторма, так как переполнились резервуары во время шторма и из-за этого мост стал слишком тяжелым. Конструкторы могли это предусмотреть и защитить от этого случая.
    - Если получил мусор на входе, то бросай ошибку на выходе, не нужно выдавать мусор на выходе.
    - Проектирование по контракту: проверяй пред- и постусловия.
    - Используй как asserts, так и обработчики ошибок.
    - Разные методы реагирования на ошибку: ошибка в расчёте дозы в софте для рентгена и в обработке кадра в видеоигре. Помни про контекст (подразумеваемые требования).
    - Исключения - это часть абстракции.
    - Метафора: чистая зона и многоуровневая стерилизация.
  - Глава 9. Программирование с псевдокодом
    - Пиши псевдокод в терминах предметной области.
    - Делай отступы внутри блока «Если».
    - Не углубляйся слишком сильно в детали.
    - Понятен ли будет этот псевдокод другому человеку? Если нет, то надо его доработать.
    - Напиши сначала псевдокод, затем название метода, затем отдельные куски кода. Это итеративный процесс.
  - Бонус: старая лекция Джошуа Блох "Как разрабатывать API" в Гугле
    - Не предлагай решения под видом требований: сервер должен работать под нагрузкой без задержек (хорошо) против паузы в GC должны быть не более 10 мс и мы должны уметь их настраивать (плохо).
    - Сформулируй требования на одной странице и выслушай комментарии всех заинтересованных людей.
    - В идеале опиши сценарий использования (use case).
    - API должен делать только одну вещь и делать ее хорошо. Если эту вещь легко объяснить, значит все хорошо.
    - Если сомневаешься, не добавляй это в АПИ: удалить это будет почти невозможно.
    - Детали реализации не должны быть видны через интерфейс. Например, в хэш-функции не нужно передавать аргумент конфигурации для указания алгоритма, достаточно знать что она возвращает целое число, которое скорее всего будет разным для двух разных объектов.
    - Скрывай по максимуму детали реализации, тогда ты сможешь легко изменять реализацию и оптимизировать модули.
    - Именование: будь последовательным. Выбери delete или remove, не используй сразу оба, не понятно в чем между ними разница.
    - Именование: используй симметричные слова.
    - Хороший код будет читаться почти как проза.
    - Документируй АПИ так, чтобы не нужно было читать код и таким образом знать детали реализации.
    - Используй наследование только там, где подкласс также является базовым классом.
- III. Переменные
  - Глава 10. Уменьшение сложности при использовании переменных
    - Избегай использования неявных переменных. Это же касается и всех остальных неявных вещей.
    - Инициализируй переменную там где она объявлена. Так проще читать и можно избежать ошибок.
    - Помещай как можно ближе друг к другу обращения к переменным.
    - Переменная должна существовать как можно меньшее количество строк кода.
    - Время связывания: во время написания кода (ниже гибкость и ниже сложность), сборки или выполнения (выше гибкость, но выше и сложность).
    - Виды данных (у них разная сложность):
      - 1. Последовательные - данные используются друг за другом.
      - 2. Селективные - выбирается один из вариантов с помощью if/else или switch.
      - 3. Итеративные - итеративные данные используются в цикле.
    - У переменной должна быть единственная цель, причём очевидная из имени.
  - Глава 11. Как называть переменные
    - Имя переменной должно быть полным, чтобы не гадать.
    - Имя отражает "что", а не "как".
    - Длинные названия переменных лучше использовать для переменных с большой областью видимости.
    - revenueTotal лучше, чем totalRevenue.
    - Во вложенном цикле лучше использовать более длинное, чем одна буква, имя.
    - Хорошие булевы имена: success, found, isManager.
    - Используй соглашения об именовании переменных.
    - Стандартные (для данной предметной области) префиксы позволяют уменьшить длину имён и улучшить читаемость: cUsers - число пользователей. Не забудь завести словарь со стандартными префиксами и опубликуй его.
    - Сокращай имена одним способом и так, чтобы они остались произносимыми.
    - Заведи словарь сокращений.
    - Не умничай: давай понятные всем имена, а не понятные только людям, знакомым с мемами или идиомами. Кстати, это же касается названий коммитов и т.п.
  - Глава 12. Типы данных
    - Без магических чисел: давай имена всем числам, значение которых может быть неясным.
    - Десятичные числа потеряют точность при использовании float или double.
    - Вместо строк используй именованные константы-строки.
    - Используй булевые переменные для упрощения сложных условий.
    - Используй enum, если это возможно: так улучшается читаемость и можно проверить на корректность значения.
    - При создании своих типов ориентируйся на имя в предметной области, а не тип представления этих данных.
  - Глава 13. Необычные типы данных
    - Используй структуры для группировки параметров в единое целое: как в функциях, так и в коде. Работать с меньшим количеством сущностей проще.
    - Вызывающий и вызываемый методы завязывается на знание о структуре данных. Проверяй, что вызываемый метод использует все поля структуры.
    - Глобальные данные нарушают сокрытие информации.
    - Глобальные данные увеличивают связанность.
    - Выполняй доступ к данным на одном и том же уровне абстракции.
- IV. Операторы
  - Глава 14. Зависимости и абстракции в последовательном коде
    - Понятно ли из кода, что методы должны вызываться в определенном порядке? Лучше явно вернуть из метода данные и передать их в следующий метод как аргумент.
    - Если улучшить код не получается, чтобы отразить зависимость порядка вызова методов, то добавь комментарий.
    - Располагай взаимосвязанные действия вместе. Это улучшит читаемость и позволит создать новую абстракцию (или хотя бы заметить ее).
    - Распечатай текст метода и обведи ручкой группы взаимосвязанных строк кода. Если группы пересекаются, то код нужно реорганизовать, чтобы они не пересекались.
  - Глава 15. Условные операторы
    - Систематически используй условия if/else. Лучше всего guard expression, но можно и основную логику вперёд, главное использовать какой-то один подход.
    - В case/if блоках упорядочивай условия: по важности, порядку встречаемости или хотя бы по алфавиту.
    - Используй if для логических проверок, а switch для перебора вариантов.
    - Используй вариант по умолчанию или последнюю проверку для выбрасывания исключения.
    - В случае использования switch комментируй сквозной переход (случай, когда специально не используется break).
  - Глава 16. Циклы
    - Чем проще условие цикла и сам цикл, тем лучше.
    - Держи все условия выхода из цикла в одном месте или хотя бы сделай это очевидным.
    - Предпочитай использовать foreach: с ним обычно не будет ошибок, он простой. Если не можешь использовать foreach используй цикл for, т.к. он проще цикла while.
    - Пусть цикл делает только одно действие. Нужно сделать два действия - напиши два цикла, чтобы каждый выполнял только одно действие.
    - Не используй значение счетчика цикла после его завершения: это неочевидно.
    - Используй счётчик безопасности, если у тебя обычный цикл и ты хочешь, чтобы он завершился.
    - Не разбрасывай операторы break по телу цикла.
    - Проверяй граничные точки цикла в уме, так можно предотвратить ошибки.
    - Пусть цикл умещается на экран целиком, его проще будет читать и понимать.
    - Используй до 3 уровней вложенности в цикле. Меньше - лучше. Используй методы, чтобы абстрагировать большие куски кода.
  - Глава 17. Нестандартные управляющие структуры
    - Используй guard expression, чтобы сразу выйти из метода и отделить обработку ошибок от основного кода.
    - Используй рекурсию тогда, когда решение станет проще, чем итеративное с точки зрения читаемости или производительности.
    - Ограничь рекурсию одним методом: рекурсия и так сложна сама по себе, чтобы ещё более усложнить ее.
  - Глава 18. Таблицы данных и табличные методы
    - Используй таблицы для хранения бизнес-логики в виде данных, а не кода. Это позволит упростить сложные условия и компактно представить бизнес-логику.
    - Значением таблицы могут быть данные, а может быть и функция. Кстати, так можно реализовать полиморфное поведение.
    - Для диапазонов тоже можно использовать таблицы: преобразуй диапазон в значение индекса таблицы.
    - Способы выбора ячейки в таблице: прямой (по ключу таблицы), индексный (для ссылки на другую таблицу, прямо как индекс первичного ключа в реляционной БД) и ступенчатый (перебор в определенном порядке, например, баллы в оценку).
    - Таблицы можно держать в конфигураторe и менять логику без изменения программы.
  - Глава 19. Общие вопросы управления
    - Используй логические функции для сокрытия сложных условий.
    - Добавь скобки для улучшения читаемости.
    - Различай & и &&.
    - Избегай вложенности больше двух операторов if. Если они у тебя есть, то скорее всего ты плохо понимаешь предметную область и организацию программы. Изучи их.
    - Структурное программирование: последовательность (операторы идут друг за другом), выбор (выполнение кода в зависимости от логического условия) и итерация (организация повторяющихся операций). В структурном программировании в функции один вход и один выход.
    - Источник сложности кроется в операции выбора. Больше операций выбора, больше и сложность. Цикломатическая сложность.
- V. Улучшение кода
  - Глава 20. Качество ПО
    - Качество ПО: внешнее (корректность, быстродействие, удобство для пользователя) и внутреннее (простота внесения изменений и эксплуатации, понятность). Нужно определить приоритет этих характеристик для данного продукта и для данной команды.
    - Тестировщик проверяет внешнее качество, а код-ревью - внутреннее.
    - Цель: улучшать качество на том этапе, где это наиболее дёшево. Предотвратить дефект дешевле, чем исправлять его.
    - Код-ревью можно делать самому, просить коллег или запрашивать внешний аудит со стороны.
    - Контролируй изменения в спецификации: делай их согласованными как на уровне требований так и на уровне кода.
    - Не получится добиться максимума по всем показателям качества: пишешь производительный код - он будет читаться хуже, чем код без оптимизаций.
    - Используй код-ревью, ручные и автоматические тесты совместно: по-отдельности они менее эффективны.
    - Нахождение ошибок на этапе код-ревью лучше, чем на этапе тестирования тем, что ошибки находятся на более раннем этапе и из-за этого их дешевле исправить.
    - На что я трачу время, в порядке убывания затрат времени и уменьшения сложности:
      - сформулировать или понять (если проблему принёс другой человек) проблему.
      - придумать решение с рассмотрением граничные случаев и влияния на всю систему (в том числе долгосрочно).
      - закодировать решение и протестировать, зарелизить.
      - Если были проблемы на предыдущих этапах, то проблема вернётся, возможно в другом виде.
  - Глава 21. Совместное конструирование
    - Совместное конструирование позволяет как устранить дефекты, так и поделиться опытом и выработать стандарты кодирования.
    - Совместное конструирование требует совместного владения кодом.
    - Парное программирование: один кодирует, а второй думает про программу в целом. Постоянно работать в паре не нужно, это затратный вид деятельности. По моему опыту лучше программировать в паре не больше часа или двух в день.
    - При инспекции кода (формальная встреча с координатором) нельзя критиковать автора, нужно найти дефекты и поделиться знаниями для улучшения кода. Устранением дефектов займётся автор кода, а во время инспекции дефекты нужно только обнаружить.
    - Используй чек-лист для проверки на дефекты. Чек-лист формируй исходя из предыдущих дефектов на проекте и из собственного опыта.
    - Анализ кода - два или более человека обсуждают как устроена система.
    - Чтение кода - по сути обычное код-ревью, которое делается асинхронно.
    - Инспекции, анализ и чтение кода позволяют найти больше дефектов и исправить их дешевле, чем на этапе тестирования.
  - Глава 22. Тестирование, которое делают разработчики
    - Разработчики выполняют тестирование методом белого (прозрачного) ящика:
      - Юнит-тестирование проверяет работу методов и классов в изоляции от остальной части системы.
      - Интеграционные тестирование проверяет совместную работу нескольких классов или компонентов.
    - Тестировщики выполняют тестирование методом чёрного ящика:
      - Регрессивное тестирование проверяет наличие багов в системе уже прошедшей тестирование на том же наборе тестов.
      - Тестирование системы проверяет работу приложения в целом в заданной конфигурации.
    - Более частое тестирование не улучшит качество ПО. Нужно менять разработку, а тестирование использовать для анализа типовых проблем. Метафора: если взвешиваться чаще и больше ничего не делать, то не похудеешь.
    - Разработчику следует отводить от 10 до 25 процентов времени на тестирование своего кода.
    - Думай о тестировании ДО написания кода. Продумай какие именно тесты нужно написать до написания кода. Для этого тщательно проанализируй требования.
    - Пиши код и тесты итеративно: не нужно писать много кода и только потом тесты - будет сложно отлаживаться, ведь непонятно на каком этапе появилась ошибка.
    - Обычно разработчики пишут недостаточное количество тестов, которые проверяют систему при неправильном вводе данных и т.п.
    - Структурированное базисное тестирование определяет минимальное число тестов, необходимое для тестирования кода. Число тестов = 1 + число слов if, for/while, and/or + число слов case.
    - Что проверять:
      - Граничные условия
      - Совместимость со старыми данными
    - Основные причины ошибок (все НЕ связаны с кодированием)
      - Недостаточное знание предметной области
      - Конфликты в требованиях и изменение требований
      - Неэффективность общения, плохая координация действий разработчиков
  - Глава 23. Отладка
    - Если часто ошибаешься или отлаживаешься, то изучи предметную область и программу, в которую вносишь изменения.
    - Предполагай, что ошибку внёс ты сам и только если уверен, что не ты, проси других проверить код.
    - Думай, а не гадай: собери данные о проблеме, сформулируй гипотезу и проверь ее. Если не помогло, то повтори ещё раз.
    - Расскажи о проблеме коллеге: формулировка проблемы помогает найти слепые пятна в рассуждениях.
    - Если долго отлаживаешься, то сделай перерыв, чтобы не концентрироваться на одном и том же (раз уж это не помогло).
    - Не доверяй на 100% сообщениям об ошибках и номерам строк, но и не игнорируй их.
    - Еще раз: пойми проблему и программу, только тогда можно быть уверенным, что проблема решена.
    - Вноси изменения по одному за раз и сохраняй каждое изменение в системе контроля версий.
    - Используй отладчик и линтер, но думай о проблеме в терминах данных и гипотезы, это важнее.
  - Глава 24. Рефакторинг
    - Требования изменяются в ходе разработки проекта, следовательно, приходится менять и код.
    - Рефакторинг - изменение внутренней структуры программы без изменения функциональности.
    - Неприятные запахи, при которых нужно делать рефакторинг:
      - Повторяющийся код
      - Длинный метод
      - Слишком много аргументов в методе
      - Класс имеет низкую связность
      - Плохие имена методов
      - Интерфейс класса или модуля не формирует согласованную абстракцию. Лучше разбить на несколько классов или модулей.
      - Shotgun surgery: для внесения небольшого изменения нужно внести изменения в несколько модулей.
    - См. список рефакторингов в этой главе.
    - Применяй рефакторинги по одному за раз, а после каждого применения тестируй программу, хотя бы минимально.
    - Лучше всего делать небольшой рефакторинг в обычных задачах: код станет лучше и при этом будет протестирован. Так безопаснее.
  - Бонус: средства обеспечения качества
    - Средства типизации - для исключения опечаток и неправильного именования полей и методов. Для Node.js можно экспортировать переменные окружения, получив работающий IntelliSense вместо использования process.env.
    - Юнит-тестирование - для минимальной проверки на работоспособность. Особенно актуально для динамических языков.
    - Интеграционные тестирование - для проверки на работоспособность подсистемы. В зависимости от теста может быть достаточно для релиза.
    - Тестирование всей системы и регрессивное тестирование - для тестирования взаимосвязанных систем, где изменение в одной системе может вызвать ошибки в другой.
    - Логирование - для быстрого поиска причин ошибок и их исправления.
    - Мониторинг - для обнаружения ошибок в продакшене.
- VII. Мастерство
  - Глава 33. Характер, привычки и работа в команде
    - Скромность: внимание ограничено, лучше сразу признать свои ограниченные возможности и заняться их компенсацией.
    - Любопытство: каждые 5-10 лет технологии кардинально меняются и если не осваивать новое, то потеряешь рыночную ценность. Для развития используй следующие подходы:
      - 1. Развивай навыки, а не просто делай малосвязанные задачи.
      - 2. Экспериментируй на пет-проектах, ошибайся на них и учись.
      - 3. Читай как другие решали проблемы и думай как это применить к своему проекту.
      - 4. Собирай информацию и анализируй прежде чем действовать.
      - 5. Изучай архитектуру и организацию команд успешных проектов.
      - 6. Читай документацию для программистов и бизнес-документацию.
      - 7. Читай книги, регулярно.
      - 8. Общайся с единомышленниками.
    - Честность с собой и другими: признавай ошибки и смирись с тем, что они будут.
    - Говори менеджеру реальные сроки по проектам и задачам, а не то, что он хочет услышать. Лучше неприятная правда, чем заваленный проект.
    - Творчество подразумевает дисциплину: делай простые вещи на автомате (выработай полезные привычки) и на полную выкладывайся, делая сложные вещи.
    - Настойчивость может мешать найти решение быстрее, особенно при отладке.
    - Различай опыт, годы выслуги и способность решать новые задачи.
    - Привычки: делая что-то старайся сразу делать это хорошо. Замени плохую привычку на хорошую: так будет проще.

